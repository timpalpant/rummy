// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service.proto

package rummy

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import deck "github.com/timpalpant/rummy/deck"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Create a new game with the given name.
// Each game must have a unique name; if the name has been
// used before, an error will be returned. Games must be
// created before they can be joined.
type CreateGameRequest struct {
	GameName string `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
}

func (m *CreateGameRequest) Reset()                    { *m = CreateGameRequest{} }
func (m *CreateGameRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateGameRequest) ProtoMessage()               {}
func (*CreateGameRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *CreateGameRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

type CreateGameResponse struct {
}

func (m *CreateGameResponse) Reset()                    { *m = CreateGameResponse{} }
func (m *CreateGameResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateGameResponse) ProtoMessage()               {}
func (*CreateGameResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

// Join a game (that must already have been created)
// as the player with the given name. Only one player with
// each name is allowed in a game. If a player with this
// name has already joined the game, the previous player id
// will be returned. If a strategy is provided, then this is a
// computer player; otherwise it is a human player that must
// initiate gameplay actions when it is their turn.
type JoinGameRequest struct {
	GameName string `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
	// The name of the player. Must be unique within a game.
	PlayerName string `protobuf:"bytes,2,opt,name=player_name,json=playerName" json:"player_name,omitempty"`
	// An optional secret used to identify this player.
	// If provided, then all game play requests for this player
	// must include this secret.
	PlayerSecret string `protobuf:"bytes,3,opt,name=player_secret,json=playerSecret" json:"player_secret,omitempty"`
	// Optional, if provided then initialize a computer player
	// with this strategy.
	Strategy string `protobuf:"bytes,4,opt,name=strategy" json:"strategy,omitempty"`
}

func (m *JoinGameRequest) Reset()                    { *m = JoinGameRequest{} }
func (m *JoinGameRequest) String() string            { return proto.CompactTextString(m) }
func (*JoinGameRequest) ProtoMessage()               {}
func (*JoinGameRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *JoinGameRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

func (m *JoinGameRequest) GetPlayerName() string {
	if m != nil {
		return m.PlayerName
	}
	return ""
}

func (m *JoinGameRequest) GetPlayerSecret() string {
	if m != nil {
		return m.PlayerSecret
	}
	return ""
}

func (m *JoinGameRequest) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

type JoinGameResponse struct {
	// The player id within this game. Must be included in all requests.
	PlayerId int32 `protobuf:"varint,1,opt,name=player_id,json=playerId" json:"player_id,omitempty"`
}

func (m *JoinGameResponse) Reset()                    { *m = JoinGameResponse{} }
func (m *JoinGameResponse) String() string            { return proto.CompactTextString(m) }
func (*JoinGameResponse) ProtoMessage()               {}
func (*JoinGameResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *JoinGameResponse) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

// Start the given name, dealing cards to each of the joined players.
// Once a game has been started, no additional players may join.
// TODO(palpant): Only let game creator start the game.
type StartGameRequest struct {
	GameName string `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
}

func (m *StartGameRequest) Reset()                    { *m = StartGameRequest{} }
func (m *StartGameRequest) String() string            { return proto.CompactTextString(m) }
func (*StartGameRequest) ProtoMessage()               {}
func (*StartGameRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *StartGameRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

type StartGameResponse struct {
}

func (m *StartGameResponse) Reset()                    { *m = StartGameResponse{} }
func (m *StartGameResponse) String() string            { return proto.CompactTextString(m) }
func (*StartGameResponse) ProtoMessage()               {}
func (*StartGameResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

// Get the publicly-observable game state.
type GetGameStateRequest struct {
	GameName string `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
}

func (m *GetGameStateRequest) Reset()                    { *m = GetGameStateRequest{} }
func (m *GetGameStateRequest) String() string            { return proto.CompactTextString(m) }
func (*GetGameStateRequest) ProtoMessage()               {}
func (*GetGameStateRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *GetGameStateRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

// Get the cards currently in a player's hand.
type GetHandCardsRequest struct {
	GameName     string `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
	PlayerId     int32  `protobuf:"varint,2,opt,name=player_id,json=playerId" json:"player_id,omitempty"`
	PlayerSecret string `protobuf:"bytes,3,opt,name=player_secret,json=playerSecret" json:"player_secret,omitempty"`
}

func (m *GetHandCardsRequest) Reset()                    { *m = GetHandCardsRequest{} }
func (m *GetHandCardsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetHandCardsRequest) ProtoMessage()               {}
func (*GetHandCardsRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *GetHandCardsRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

func (m *GetHandCardsRequest) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *GetHandCardsRequest) GetPlayerSecret() string {
	if m != nil {
		return m.PlayerSecret
	}
	return ""
}

type GetHandCardsResponse struct {
	Cards []*deck.Card `protobuf:"bytes,1,rep,name=cards" json:"cards,omitempty"`
}

func (m *GetHandCardsResponse) Reset()                    { *m = GetHandCardsResponse{} }
func (m *GetHandCardsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetHandCardsResponse) ProtoMessage()               {}
func (*GetHandCardsResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *GetHandCardsResponse) GetCards() []*deck.Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

// Subscribe to game events. This allows players to observe the
// gameplay of other players.
type SubscribeGameRequest struct {
	GameName string `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
}

func (m *SubscribeGameRequest) Reset()                    { *m = SubscribeGameRequest{} }
func (m *SubscribeGameRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeGameRequest) ProtoMessage()               {}
func (*SubscribeGameRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *SubscribeGameRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

// Pick up a card from the stock. A player should initiate this request
// when beginning their turn. Alternatively, a player may issue a
// PickUpDiscardRequest.
type PickUpStockRequest struct {
	GameName     string `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
	PlayerId     int32  `protobuf:"varint,2,opt,name=player_id,json=playerId" json:"player_id,omitempty"`
	PlayerSecret string `protobuf:"bytes,3,opt,name=player_secret,json=playerSecret" json:"player_secret,omitempty"`
}

func (m *PickUpStockRequest) Reset()                    { *m = PickUpStockRequest{} }
func (m *PickUpStockRequest) String() string            { return proto.CompactTextString(m) }
func (*PickUpStockRequest) ProtoMessage()               {}
func (*PickUpStockRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func (m *PickUpStockRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

func (m *PickUpStockRequest) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *PickUpStockRequest) GetPlayerSecret() string {
	if m != nil {
		return m.PlayerSecret
	}
	return ""
}

// Returns the card that was picked up from the stock.
type PickUpStockResponse struct {
	Card *deck.Card `protobuf:"bytes,1,opt,name=card" json:"card,omitempty"`
}

func (m *PickUpStockResponse) Reset()                    { *m = PickUpStockResponse{} }
func (m *PickUpStockResponse) String() string            { return proto.CompactTextString(m) }
func (*PickUpStockResponse) ProtoMessage()               {}
func (*PickUpStockResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func (m *PickUpStockResponse) GetCard() *deck.Card {
	if m != nil {
		return m.Card
	}
	return nil
}

// Pick up N cards from the discard pile. A player may initiate this
// request when beginning their turn. Alternatively, a player may pick
// up a card from the stock. The N cards picked up are from the top of
// the discard stack. The bottom-most card must be played this turn.
type PickUpDiscardRequest struct {
	GameName     string `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
	PlayerId     int32  `protobuf:"varint,2,opt,name=player_id,json=playerId" json:"player_id,omitempty"`
	PlayerSecret string `protobuf:"bytes,3,opt,name=player_secret,json=playerSecret" json:"player_secret,omitempty"`
	NCards       int32  `protobuf:"varint,4,opt,name=n_cards,json=nCards" json:"n_cards,omitempty"`
}

func (m *PickUpDiscardRequest) Reset()                    { *m = PickUpDiscardRequest{} }
func (m *PickUpDiscardRequest) String() string            { return proto.CompactTextString(m) }
func (*PickUpDiscardRequest) ProtoMessage()               {}
func (*PickUpDiscardRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12} }

func (m *PickUpDiscardRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

func (m *PickUpDiscardRequest) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *PickUpDiscardRequest) GetPlayerSecret() string {
	if m != nil {
		return m.PlayerSecret
	}
	return ""
}

func (m *PickUpDiscardRequest) GetNCards() int32 {
	if m != nil {
		return m.NCards
	}
	return 0
}

// Returns the cards picked up from the discard pile.
type PickUpDiscardResponse struct {
	Cards []*deck.Card `protobuf:"bytes,1,rep,name=cards" json:"cards,omitempty"`
}

func (m *PickUpDiscardResponse) Reset()                    { *m = PickUpDiscardResponse{} }
func (m *PickUpDiscardResponse) String() string            { return proto.CompactTextString(m) }
func (*PickUpDiscardResponse) ProtoMessage()               {}
func (*PickUpDiscardResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{13} }

func (m *PickUpDiscardResponse) GetCards() []*deck.Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

// Play cards for points. The cards must either form a new Meld,
// or rummy off of a meld that has previously been played (by any player).
// Players may issue this request only when it is their turn and they have
// picked up cards (either from the stock or the discard pile).
// This request may be issued multiple times in a single turn.
type PlayCardsRequest struct {
	GameName     string       `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
	PlayerId     int32        `protobuf:"varint,2,opt,name=player_id,json=playerId" json:"player_id,omitempty"`
	PlayerSecret string       `protobuf:"bytes,3,opt,name=player_secret,json=playerSecret" json:"player_secret,omitempty"`
	Cards        []*deck.Card `protobuf:"bytes,4,rep,name=cards" json:"cards,omitempty"`
}

func (m *PlayCardsRequest) Reset()                    { *m = PlayCardsRequest{} }
func (m *PlayCardsRequest) String() string            { return proto.CompactTextString(m) }
func (*PlayCardsRequest) ProtoMessage()               {}
func (*PlayCardsRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{14} }

func (m *PlayCardsRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

func (m *PlayCardsRequest) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *PlayCardsRequest) GetPlayerSecret() string {
	if m != nil {
		return m.PlayerSecret
	}
	return ""
}

func (m *PlayCardsRequest) GetCards() []*deck.Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

type PlayCardsResponse struct {
	Score int32 `protobuf:"varint,1,opt,name=score" json:"score,omitempty"`
}

func (m *PlayCardsResponse) Reset()                    { *m = PlayCardsResponse{} }
func (m *PlayCardsResponse) String() string            { return proto.CompactTextString(m) }
func (*PlayCardsResponse) ProtoMessage()               {}
func (*PlayCardsResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{15} }

func (m *PlayCardsResponse) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

// Discard a card from hand into the discard pile.
// Players may play this card after picking up cards and (optionally)
// playing cards for points. Discarding a card ends the player's turn.
type DiscardCardRequest struct {
	GameName     string     `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
	PlayerId     int32      `protobuf:"varint,2,opt,name=player_id,json=playerId" json:"player_id,omitempty"`
	PlayerSecret string     `protobuf:"bytes,3,opt,name=player_secret,json=playerSecret" json:"player_secret,omitempty"`
	Card         *deck.Card `protobuf:"bytes,4,opt,name=card" json:"card,omitempty"`
}

func (m *DiscardCardRequest) Reset()                    { *m = DiscardCardRequest{} }
func (m *DiscardCardRequest) String() string            { return proto.CompactTextString(m) }
func (*DiscardCardRequest) ProtoMessage()               {}
func (*DiscardCardRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{16} }

func (m *DiscardCardRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

func (m *DiscardCardRequest) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *DiscardCardRequest) GetPlayerSecret() string {
	if m != nil {
		return m.PlayerSecret
	}
	return ""
}

func (m *DiscardCardRequest) GetCard() *deck.Card {
	if m != nil {
		return m.Card
	}
	return nil
}

type DiscardCardResponse struct {
}

func (m *DiscardCardResponse) Reset()                    { *m = DiscardCardResponse{} }
func (m *DiscardCardResponse) String() string            { return proto.CompactTextString(m) }
func (*DiscardCardResponse) ProtoMessage()               {}
func (*DiscardCardResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{17} }

// Call a rummy observed in the discard pile. This request may be performed
// at any time when a player observes that a possible rummy has been created
// either as the result of a discard or newly played cards.
type CallRummyRequest struct {
	GameName     string       `protobuf:"bytes,1,opt,name=game_name,json=gameName" json:"game_name,omitempty"`
	PlayerId     int32        `protobuf:"varint,2,opt,name=player_id,json=playerId" json:"player_id,omitempty"`
	PlayerSecret string       `protobuf:"bytes,3,opt,name=player_secret,json=playerSecret" json:"player_secret,omitempty"`
	Cards        []*deck.Card `protobuf:"bytes,4,rep,name=cards" json:"cards,omitempty"`
}

func (m *CallRummyRequest) Reset()                    { *m = CallRummyRequest{} }
func (m *CallRummyRequest) String() string            { return proto.CompactTextString(m) }
func (*CallRummyRequest) ProtoMessage()               {}
func (*CallRummyRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18} }

func (m *CallRummyRequest) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

func (m *CallRummyRequest) GetPlayerId() int32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *CallRummyRequest) GetPlayerSecret() string {
	if m != nil {
		return m.PlayerSecret
	}
	return ""
}

func (m *CallRummyRequest) GetCards() []*deck.Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

type CallRummyResponse struct {
}

func (m *CallRummyResponse) Reset()                    { *m = CallRummyResponse{} }
func (m *CallRummyResponse) String() string            { return proto.CompactTextString(m) }
func (*CallRummyResponse) ProtoMessage()               {}
func (*CallRummyResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{19} }

func init() {
	proto.RegisterType((*CreateGameRequest)(nil), "rummy.CreateGameRequest")
	proto.RegisterType((*CreateGameResponse)(nil), "rummy.CreateGameResponse")
	proto.RegisterType((*JoinGameRequest)(nil), "rummy.JoinGameRequest")
	proto.RegisterType((*JoinGameResponse)(nil), "rummy.JoinGameResponse")
	proto.RegisterType((*StartGameRequest)(nil), "rummy.StartGameRequest")
	proto.RegisterType((*StartGameResponse)(nil), "rummy.StartGameResponse")
	proto.RegisterType((*GetGameStateRequest)(nil), "rummy.GetGameStateRequest")
	proto.RegisterType((*GetHandCardsRequest)(nil), "rummy.GetHandCardsRequest")
	proto.RegisterType((*GetHandCardsResponse)(nil), "rummy.GetHandCardsResponse")
	proto.RegisterType((*SubscribeGameRequest)(nil), "rummy.SubscribeGameRequest")
	proto.RegisterType((*PickUpStockRequest)(nil), "rummy.PickUpStockRequest")
	proto.RegisterType((*PickUpStockResponse)(nil), "rummy.PickUpStockResponse")
	proto.RegisterType((*PickUpDiscardRequest)(nil), "rummy.PickUpDiscardRequest")
	proto.RegisterType((*PickUpDiscardResponse)(nil), "rummy.PickUpDiscardResponse")
	proto.RegisterType((*PlayCardsRequest)(nil), "rummy.PlayCardsRequest")
	proto.RegisterType((*PlayCardsResponse)(nil), "rummy.PlayCardsResponse")
	proto.RegisterType((*DiscardCardRequest)(nil), "rummy.DiscardCardRequest")
	proto.RegisterType((*DiscardCardResponse)(nil), "rummy.DiscardCardResponse")
	proto.RegisterType((*CallRummyRequest)(nil), "rummy.CallRummyRequest")
	proto.RegisterType((*CallRummyResponse)(nil), "rummy.CallRummyResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RummyService service

type RummyServiceClient interface {
	CreateGame(ctx context.Context, in *CreateGameRequest, opts ...grpc.CallOption) (*CreateGameResponse, error)
	JoinGame(ctx context.Context, in *JoinGameRequest, opts ...grpc.CallOption) (*JoinGameResponse, error)
	StartGame(ctx context.Context, in *StartGameRequest, opts ...grpc.CallOption) (*StartGameResponse, error)
	SubscribeGame(ctx context.Context, in *SubscribeGameRequest, opts ...grpc.CallOption) (RummyService_SubscribeGameClient, error)
	GetGameState(ctx context.Context, in *GetGameStateRequest, opts ...grpc.CallOption) (*GameState, error)
	GetHandCards(ctx context.Context, in *GetHandCardsRequest, opts ...grpc.CallOption) (*GetHandCardsResponse, error)
	PickUpStock(ctx context.Context, in *PickUpStockRequest, opts ...grpc.CallOption) (*PickUpStockResponse, error)
	PickUpDiscard(ctx context.Context, in *PickUpDiscardRequest, opts ...grpc.CallOption) (*PickUpDiscardResponse, error)
	PlayCards(ctx context.Context, in *PlayCardsRequest, opts ...grpc.CallOption) (*PlayCardsResponse, error)
	DiscardCard(ctx context.Context, in *DiscardCardRequest, opts ...grpc.CallOption) (*DiscardCardResponse, error)
	CallRummy(ctx context.Context, in *CallRummyRequest, opts ...grpc.CallOption) (*CallRummyResponse, error)
}

type rummyServiceClient struct {
	cc *grpc.ClientConn
}

func NewRummyServiceClient(cc *grpc.ClientConn) RummyServiceClient {
	return &rummyServiceClient{cc}
}

func (c *rummyServiceClient) CreateGame(ctx context.Context, in *CreateGameRequest, opts ...grpc.CallOption) (*CreateGameResponse, error) {
	out := new(CreateGameResponse)
	err := grpc.Invoke(ctx, "/rummy.RummyService/CreateGame", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rummyServiceClient) JoinGame(ctx context.Context, in *JoinGameRequest, opts ...grpc.CallOption) (*JoinGameResponse, error) {
	out := new(JoinGameResponse)
	err := grpc.Invoke(ctx, "/rummy.RummyService/JoinGame", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rummyServiceClient) StartGame(ctx context.Context, in *StartGameRequest, opts ...grpc.CallOption) (*StartGameResponse, error) {
	out := new(StartGameResponse)
	err := grpc.Invoke(ctx, "/rummy.RummyService/StartGame", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rummyServiceClient) SubscribeGame(ctx context.Context, in *SubscribeGameRequest, opts ...grpc.CallOption) (RummyService_SubscribeGameClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RummyService_serviceDesc.Streams[0], c.cc, "/rummy.RummyService/SubscribeGame", opts...)
	if err != nil {
		return nil, err
	}
	x := &rummyServiceSubscribeGameClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RummyService_SubscribeGameClient interface {
	Recv() (*GameEvent, error)
	grpc.ClientStream
}

type rummyServiceSubscribeGameClient struct {
	grpc.ClientStream
}

func (x *rummyServiceSubscribeGameClient) Recv() (*GameEvent, error) {
	m := new(GameEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rummyServiceClient) GetGameState(ctx context.Context, in *GetGameStateRequest, opts ...grpc.CallOption) (*GameState, error) {
	out := new(GameState)
	err := grpc.Invoke(ctx, "/rummy.RummyService/GetGameState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rummyServiceClient) GetHandCards(ctx context.Context, in *GetHandCardsRequest, opts ...grpc.CallOption) (*GetHandCardsResponse, error) {
	out := new(GetHandCardsResponse)
	err := grpc.Invoke(ctx, "/rummy.RummyService/GetHandCards", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rummyServiceClient) PickUpStock(ctx context.Context, in *PickUpStockRequest, opts ...grpc.CallOption) (*PickUpStockResponse, error) {
	out := new(PickUpStockResponse)
	err := grpc.Invoke(ctx, "/rummy.RummyService/PickUpStock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rummyServiceClient) PickUpDiscard(ctx context.Context, in *PickUpDiscardRequest, opts ...grpc.CallOption) (*PickUpDiscardResponse, error) {
	out := new(PickUpDiscardResponse)
	err := grpc.Invoke(ctx, "/rummy.RummyService/PickUpDiscard", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rummyServiceClient) PlayCards(ctx context.Context, in *PlayCardsRequest, opts ...grpc.CallOption) (*PlayCardsResponse, error) {
	out := new(PlayCardsResponse)
	err := grpc.Invoke(ctx, "/rummy.RummyService/PlayCards", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rummyServiceClient) DiscardCard(ctx context.Context, in *DiscardCardRequest, opts ...grpc.CallOption) (*DiscardCardResponse, error) {
	out := new(DiscardCardResponse)
	err := grpc.Invoke(ctx, "/rummy.RummyService/DiscardCard", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rummyServiceClient) CallRummy(ctx context.Context, in *CallRummyRequest, opts ...grpc.CallOption) (*CallRummyResponse, error) {
	out := new(CallRummyResponse)
	err := grpc.Invoke(ctx, "/rummy.RummyService/CallRummy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RummyService service

type RummyServiceServer interface {
	CreateGame(context.Context, *CreateGameRequest) (*CreateGameResponse, error)
	JoinGame(context.Context, *JoinGameRequest) (*JoinGameResponse, error)
	StartGame(context.Context, *StartGameRequest) (*StartGameResponse, error)
	SubscribeGame(*SubscribeGameRequest, RummyService_SubscribeGameServer) error
	GetGameState(context.Context, *GetGameStateRequest) (*GameState, error)
	GetHandCards(context.Context, *GetHandCardsRequest) (*GetHandCardsResponse, error)
	PickUpStock(context.Context, *PickUpStockRequest) (*PickUpStockResponse, error)
	PickUpDiscard(context.Context, *PickUpDiscardRequest) (*PickUpDiscardResponse, error)
	PlayCards(context.Context, *PlayCardsRequest) (*PlayCardsResponse, error)
	DiscardCard(context.Context, *DiscardCardRequest) (*DiscardCardResponse, error)
	CallRummy(context.Context, *CallRummyRequest) (*CallRummyResponse, error)
}

func RegisterRummyServiceServer(s *grpc.Server, srv RummyServiceServer) {
	s.RegisterService(&_RummyService_serviceDesc, srv)
}

func _RummyService_CreateGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RummyServiceServer).CreateGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rummy.RummyService/CreateGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RummyServiceServer).CreateGame(ctx, req.(*CreateGameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RummyService_JoinGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinGameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RummyServiceServer).JoinGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rummy.RummyService/JoinGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RummyServiceServer).JoinGame(ctx, req.(*JoinGameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RummyService_StartGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartGameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RummyServiceServer).StartGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rummy.RummyService/StartGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RummyServiceServer).StartGame(ctx, req.(*StartGameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RummyService_SubscribeGame_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeGameRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RummyServiceServer).SubscribeGame(m, &rummyServiceSubscribeGameServer{stream})
}

type RummyService_SubscribeGameServer interface {
	Send(*GameEvent) error
	grpc.ServerStream
}

type rummyServiceSubscribeGameServer struct {
	grpc.ServerStream
}

func (x *rummyServiceSubscribeGameServer) Send(m *GameEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _RummyService_GetGameState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGameStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RummyServiceServer).GetGameState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rummy.RummyService/GetGameState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RummyServiceServer).GetGameState(ctx, req.(*GetGameStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RummyService_GetHandCards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHandCardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RummyServiceServer).GetHandCards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rummy.RummyService/GetHandCards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RummyServiceServer).GetHandCards(ctx, req.(*GetHandCardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RummyService_PickUpStock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PickUpStockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RummyServiceServer).PickUpStock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rummy.RummyService/PickUpStock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RummyServiceServer).PickUpStock(ctx, req.(*PickUpStockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RummyService_PickUpDiscard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PickUpDiscardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RummyServiceServer).PickUpDiscard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rummy.RummyService/PickUpDiscard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RummyServiceServer).PickUpDiscard(ctx, req.(*PickUpDiscardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RummyService_PlayCards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayCardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RummyServiceServer).PlayCards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rummy.RummyService/PlayCards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RummyServiceServer).PlayCards(ctx, req.(*PlayCardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RummyService_DiscardCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscardCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RummyServiceServer).DiscardCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rummy.RummyService/DiscardCard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RummyServiceServer).DiscardCard(ctx, req.(*DiscardCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RummyService_CallRummy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallRummyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RummyServiceServer).CallRummy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rummy.RummyService/CallRummy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RummyServiceServer).CallRummy(ctx, req.(*CallRummyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RummyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rummy.RummyService",
	HandlerType: (*RummyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateGame",
			Handler:    _RummyService_CreateGame_Handler,
		},
		{
			MethodName: "JoinGame",
			Handler:    _RummyService_JoinGame_Handler,
		},
		{
			MethodName: "StartGame",
			Handler:    _RummyService_StartGame_Handler,
		},
		{
			MethodName: "GetGameState",
			Handler:    _RummyService_GetGameState_Handler,
		},
		{
			MethodName: "GetHandCards",
			Handler:    _RummyService_GetHandCards_Handler,
		},
		{
			MethodName: "PickUpStock",
			Handler:    _RummyService_PickUpStock_Handler,
		},
		{
			MethodName: "PickUpDiscard",
			Handler:    _RummyService_PickUpDiscard_Handler,
		},
		{
			MethodName: "PlayCards",
			Handler:    _RummyService_PlayCards_Handler,
		},
		{
			MethodName: "DiscardCard",
			Handler:    _RummyService_DiscardCard_Handler,
		},
		{
			MethodName: "CallRummy",
			Handler:    _RummyService_CallRummy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeGame",
			Handler:       _RummyService_SubscribeGame_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

func init() { proto.RegisterFile("service.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 852 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcd, 0x6a, 0x23, 0x47,
	0x10, 0x66, 0x6c, 0xc9, 0x91, 0x4a, 0x56, 0x22, 0xb5, 0x64, 0x59, 0x1e, 0x39, 0x8e, 0xd2, 0xb9,
	0x38, 0x0e, 0x68, 0xfc, 0x43, 0x88, 0xe3, 0x43, 0x2e, 0x4a, 0x70, 0x92, 0x43, 0x30, 0x12, 0x39,
	0xac, 0x77, 0x17, 0xd1, 0x9a, 0x69, 0xe4, 0xb1, 0xe6, 0x6f, 0x67, 0x5a, 0x06, 0x61, 0x0c, 0xcb,
	0x3e, 0xc0, 0xb2, 0xe0, 0x47, 0xdb, 0x57, 0xd8, 0x67, 0xd8, 0xf3, 0xd2, 0x3d, 0x3d, 0xe3, 0xf9,
	0x33, 0xe8, 0x24, 0xf6, 0x62, 0x50, 0xfd, 0x7c, 0x5f, 0x55, 0x75, 0xcd, 0x57, 0x86, 0x7a, 0x40,
	0xfd, 0x3b, 0x53, 0xa7, 0x03, 0xcf, 0x77, 0x99, 0x8b, 0xca, 0xfe, 0xc2, 0xb6, 0x97, 0xea, 0xfe,
	0xcc, 0x75, 0x67, 0x16, 0xd5, 0x88, 0x67, 0x6a, 0xc4, 0x71, 0x5c, 0x46, 0x98, 0xe9, 0x3a, 0x41,
	0x18, 0xa4, 0xfe, 0x32, 0x33, 0xd9, 0xcd, 0x62, 0x3a, 0xd0, 0x5d, 0x5b, 0x63, 0xa6, 0xed, 0x11,
	0xcb, 0x23, 0x0e, 0xd3, 0x44, 0xaa, 0x66, 0x50, 0x7d, 0x2e, 0xfe, 0xc8, 0x60, 0x98, 0x11, 0x5b,
	0xa2, 0xe3, 0x63, 0x68, 0x0e, 0x7d, 0x4a, 0x18, 0xbd, 0x24, 0x36, 0x1d, 0xd1, 0x37, 0x0b, 0x1a,
	0x30, 0xd4, 0x83, 0x2a, 0x0f, 0x99, 0x38, 0xc4, 0xa6, 0x5d, 0xa5, 0xaf, 0x1c, 0x56, 0x47, 0x15,
	0x6e, 0xf8, 0x8f, 0xd8, 0x14, 0xb7, 0x01, 0x25, 0x33, 0x02, 0xcf, 0x75, 0x02, 0x8a, 0x3f, 0x28,
	0xf0, 0xdd, 0xbf, 0xae, 0xe9, 0xac, 0x0a, 0x83, 0x7e, 0x80, 0x9a, 0x67, 0x91, 0x25, 0xf5, 0x43,
	0xf7, 0x86, 0x70, 0x43, 0x68, 0x12, 0x01, 0x3f, 0x41, 0x5d, 0x06, 0x04, 0x54, 0xf7, 0x29, 0xeb,
	0x6e, 0x8a, 0x90, 0xed, 0xd0, 0x38, 0x16, 0x36, 0xa4, 0x42, 0x25, 0x60, 0x3e, 0x61, 0x74, 0xb6,
	0xec, 0x96, 0x42, 0x86, 0xe8, 0x37, 0xd6, 0xa0, 0xf1, 0x54, 0x51, 0x58, 0x26, 0x2f, 0x49, 0x82,
	0x9a, 0x86, 0x28, 0xa9, 0x3c, 0xaa, 0x84, 0x86, 0x7f, 0x0c, 0x9e, 0x30, 0x66, 0xc4, 0x67, 0x2b,
	0x8f, 0xa2, 0x05, 0xcd, 0x44, 0x82, 0x9c, 0xc4, 0x29, 0xb4, 0x2e, 0xa9, 0x30, 0x8d, 0x19, 0x61,
	0xab, 0x01, 0x31, 0x91, 0xf3, 0x37, 0x71, 0x8c, 0x21, 0xf1, 0x8d, 0x60, 0xa5, 0x01, 0xa6, 0x5a,
	0xd9, 0x48, 0xb7, 0xb2, 0xd2, 0xf0, 0xf0, 0x39, 0xb4, 0xd3, 0xac, 0x72, 0x48, 0x7d, 0x28, 0xeb,
	0xdc, 0xd0, 0x55, 0xfa, 0x9b, 0x87, 0xb5, 0x53, 0x18, 0x88, 0xdd, 0xe1, 0x31, 0xa3, 0xd0, 0x81,
	0xcf, 0xa0, 0x3d, 0x5e, 0x4c, 0x03, 0xdd, 0x37, 0xa7, 0xab, 0x2f, 0x4e, 0x00, 0xe8, 0xca, 0xd4,
	0xe7, 0xff, 0x7b, 0x63, 0xe6, 0xea, 0xf3, 0x35, 0xf5, 0xf8, 0x2b, 0xb4, 0x52, 0xa4, 0xb2, 0xc5,
	0x03, 0x28, 0xf1, 0x4e, 0x04, 0x61, 0xba, 0x43, 0x61, 0xc7, 0xef, 0x15, 0x68, 0x87, 0x79, 0x7f,
	0x9a, 0x01, 0xb7, 0xac, 0xa7, 0x5c, 0xb4, 0x0b, 0xdf, 0x38, 0x93, 0x70, 0xf8, 0x25, 0x91, 0xbf,
	0xe5, 0x88, 0xb7, 0xc1, 0xbf, 0xc3, 0x4e, 0xa6, 0x9e, 0x95, 0x1f, 0xeb, 0x51, 0x81, 0xc6, 0x95,
	0x45, 0x96, 0x6b, 0x5c, 0xad, 0xa7, 0xaa, 0x4a, 0xcf, 0x55, 0xf5, 0x33, 0x34, 0x13, 0x45, 0xc9,
	0x66, 0xda, 0x50, 0x0e, 0x74, 0xd7, 0xa7, 0xf2, 0xd3, 0x0c, 0x7f, 0xf0, 0x06, 0x90, 0x6c, 0x7b,
	0xb8, 0xbe, 0xa7, 0x88, 0x56, 0xa4, 0xf4, 0xcc, 0x8a, 0xec, 0x40, 0x2b, 0x55, 0x94, 0xfc, 0xfc,
	0xf9, 0xb4, 0x87, 0xc4, 0xb2, 0x46, 0x5c, 0x7a, 0xbf, 0x9a, 0x69, 0xb7, 0xa0, 0x99, 0x28, 0x2a,
	0x2c, 0xf5, 0xf4, 0x73, 0x05, 0xb6, 0x85, 0x65, 0x1c, 0x1e, 0x1c, 0x44, 0x00, 0x9e, 0xa4, 0x1d,
	0x75, 0x07, 0xe2, 0x7c, 0x0c, 0x72, 0xf7, 0x41, 0xdd, 0x2b, 0xf0, 0xc8, 0xf6, 0x0f, 0xde, 0x7d,
	0xfc, 0xf4, 0xb8, 0xd1, 0xc5, 0x1d, 0xed, 0xee, 0x44, 0xd3, 0x85, 0x5f, 0xbb, 0x8f, 0x7b, 0x7f,
	0x40, 0xf7, 0x50, 0x89, 0x44, 0x19, 0x75, 0x24, 0x4c, 0xe6, 0x6e, 0xa8, 0xbb, 0x39, 0xbb, 0x04,
	0xff, 0x43, 0x80, 0x9f, 0x63, 0xcc, 0xc1, 0x6f, 0x5d, 0xd3, 0x49, 0x42, 0x6b, 0xf7, 0x89, 0x7b,
	0xf2, 0x70, 0x8d, 0x70, 0x3d, 0x8a, 0x9a, 0xf0, 0xa0, 0x0b, 0xe5, 0x08, 0xbd, 0x86, 0x6a, 0xac,
	0xd7, 0x28, 0x62, 0xc9, 0x4a, 0xbe, 0xda, 0xcd, 0x3b, 0x24, 0xff, 0xf7, 0x82, 0x7f, 0x17, 0xef,
	0x70, 0xe4, 0x80, 0xbb, 0x53, 0xbd, 0xe9, 0x50, 0x4f, 0xa9, 0x22, 0xea, 0x45, 0x48, 0x05, 0x5a,
	0xa9, 0x36, 0xa4, 0x93, 0xdb, 0xfe, 0xba, 0xa3, 0x0e, 0xc3, 0x3f, 0x0a, 0xf8, 0x1e, 0xda, 0x13,
	0xf0, 0x51, 0x4e, 0x92, 0xe2, 0x58, 0x41, 0x2f, 0x61, 0x3b, 0x79, 0x5e, 0x90, 0x1a, 0xc1, 0xe4,
	0x6f, 0x4e, 0x8a, 0x42, 0x38, 0xa2, 0x0e, 0x50, 0xd4, 0x41, 0xe6, 0x75, 0xde, 0x2a, 0x02, 0x3d,
	0x3e, 0x09, 0x49, 0xf4, 0xec, 0x75, 0x52, 0x7b, 0x85, 0x3e, 0x39, 0xaa, 0xdf, 0x04, 0xd1, 0x09,
	0xea, 0x73, 0xa2, 0x1b, 0xe2, 0x18, 0x85, 0x4f, 0x65, 0x1a, 0x0f, 0xd7, 0x75, 0x5c, 0x89, 0x62,
	0xf8, 0x1b, 0x4d, 0xa1, 0x96, 0x10, 0x6c, 0x14, 0xad, 0x5a, 0xfe, 0x72, 0xa8, 0x6a, 0x91, 0x4b,
	0xd2, 0xef, 0x0b, 0xfa, 0x0e, 0x6e, 0x72, 0x68, 0xcf, 0xd4, 0xe7, 0x93, 0x85, 0x37, 0x09, 0x78,
	0x08, 0xe7, 0xb8, 0x85, 0x7a, 0x4a, 0x4c, 0xe3, 0x87, 0x2a, 0x92, 0x7c, 0x75, 0xbf, 0xd8, 0x99,
	0x59, 0xf8, 0x56, 0x92, 0xc9, 0x08, 0x83, 0x38, 0xd7, 0x0b, 0xa8, 0xc6, 0x3a, 0x17, 0xef, 0x5c,
	0x56, 0x8e, 0xe3, 0x9d, 0xcb, 0x49, 0x22, 0xde, 0x13, 0xf8, 0x2d, 0xfc, 0xad, 0xc0, 0xb7, 0xc8,
	0x32, 0x3c, 0x0f, 0x1c, 0xfa, 0x15, 0xd4, 0x12, 0x0a, 0x14, 0x8f, 0x2a, 0x2f, 0x95, 0xf1, 0xa8,
	0x8a, 0x04, 0xab, 0x23, 0x08, 0x1a, 0xb8, 0xc6, 0x09, 0xd2, 0x85, 0xc7, 0x92, 0x11, 0x17, 0x9e,
	0x55, 0xb6, 0xb8, 0xf0, 0x9c, 0xba, 0xa4, 0x0b, 0xd7, 0x89, 0x65, 0x4d, 0x44, 0xe4, 0x85, 0x72,
	0x34, 0xdd, 0x12, 0xff, 0x7b, 0x9e, 0x7d, 0x09, 0x00, 0x00, 0xff, 0xff, 0x71, 0x1c, 0x83, 0x93,
	0xea, 0x0a, 0x00, 0x00,
}
